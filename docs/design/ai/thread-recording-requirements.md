# Thread记录功能需求文档

## 文档信息
- **文档名称**: Thread记录功能需求文档
- **创建日期**: 2025-01-14
- **版本**: 1.0
- **状态**: 已确认

## 1. 需求概述

### 1.1 背景
在复杂的软件开发任务中，经常需要与AI进行连续的多次交互来完成一个完整任务。为了保持上下文的连续性和提高AI服务的质量，需要实现Thread记录功能。

### 1.2 目标
- 为连续任务提供上下文保持能力
- 通过手动控制机制，灵活启用Thread记录
- 使用可读性强的格式存储交互历史
- 便于后续的调试、分析和任务跟踪

### 1.3 适用场景
- 代码重构项目
- 复杂系统设计
- 调试和故障排查
- 文档编写和维护
- 其他需要连续交互的复杂任务

## 2. 核心需求

### 2.1 手动控制
- **启用方式**: 用户手动控制Thread记录的开始
- **默认状态**: 默认不启用Thread记录
- **灵活性**: 用户可以根据任务需要决定是否启用

### 2.2 文件存储
- **存储格式**: Markdown文件 (.md)
- **文件命名**: `thread-YYYY-MM-DD.md`
- **生命周期**: 以天为单位，每天一个Thread文件
- **存储位置**: 待确定（需要后续讨论）

### 2.3 记录内容
#### 必须记录的元数据
- **时间戳**: 精确到秒的交互时间
- **模型名称**: 使用的AI模型
- **AI角色**: 当前的AI角色（Developer, Operations, KnowledgeManager）
- **用户请求**: 完整的用户输入内容
- **AI响应**: 总结性内容（非完整响应）

## 3. 详细设计规范

### 3.1 文件结构模板
```markdown
# Thread记录 - YYYY-MM-DD

## 交互记录 1
**时间**: YYYY-MM-DD HH:MM:SS
**模型**: model-name
**角色**: role-name

### 用户请求
```text
用户输入的完整内容...
```

### AI响应（总结）
提取的总结性内容（200-250字）...

## 交互记录 2
**时间**: YYYY-MM-DD HH:MM:SS
**模型**: model-name
**角色**: role-name

### 用户请求
```text
用户输入的完整内容...
```

### AI响应（总结）
提取的总结性内容（200-250字）...
```

### 3.2 总结性内容提取规则

#### 3.2.1 关键字识别
**中文关键字列表**:
- 总结
- 总之
- 综上所述
- 总的来说
- 结论
- 概要
- 摘要
- 最终
- 归纳起来
- 简而言之
- 简单来说
- 简单地讲
- 总体而言
- 整体来看
- 整体而言
- 从整体上
- 总体来说
- 大体而言
- 大体来说
- 基本上
- 基本而言

**英文关键字列表**:
- summary
- conclusion
- in summary
- to summarize
- in conclusion
- to conclude
- overall
- in short
- briefly
- in brief
- essentially
- basically
- ultimately
- finally
- in essence
- to sum up

**识别规则**:
- 不区分大小写
- 支持中英文混合
- 关键字可以出现在段落的任何位置

#### 3.2.2 段落选择逻辑
1. **优先级顺序**:
   - 第一优先级：第一个包含总结关键字的段落
   - 第二优先级：最后一个段落

2. **选择算法**:
   ```rust
   // 伪代码描述
   1. 将AI响应按段落分割
   2. 遍历所有段落，寻找包含总结关键字的段落
   3. 如果找到总结段落：
      - 选择第一个包含总结关键字的段落
      - 应用字数控制规则
   4. 如果没有找到总结段落：
      - 选择最后一个段落
      - 应用字数控制规则
   5. 如果选择的段落太短：
      - 考虑合并相邻段落来满足字数要求
   ```

#### 3.2.3 字数控制规则
- **目标字数范围**: 200-250字
- **截断策略**:
  - 如果段落超过250字，在最近的完整句子处截断
  - 如果段落少于200字，保持原样不额外处理
  - 截断优先在句号(。)、问号(？)、感叹号(！)处进行
  - 保持句子完整性，避免在词中间截断

### 3.3 边界情况处理

#### 3.3.1 多个总结段落
- 优先选择**第一个**包含总结关键字的段落
- 如果第一个总结段落太短，可以考虑合并后续的总结段落

#### 3.3.2 最后段落太短
- 如果最后段落不足200字，按以下顺序处理：
  1. 尝试合并倒数第二段
  2. 如果还是不够，继续向前合并直到满足字数要求
  3. 只合并相邻的段落，不跳跃合并

#### 3.3.3 完全没有合适内容
- 如果所有段落都很短，且找不到总结内容：
  - 选择内容最丰富的段落
  - 或者直接记录最后几个段落的组合

## 4. 具体示例

### 4.1 正常情况示例

#### 示例1：找到总结关键字
**原始AI响应**:
```
这是一个复杂的技术问题，需要从多个角度进行分析。首先，我们需要考虑性能因素，包括算法时间复杂度和空间复杂度。其次，还要考虑代码的可维护性和可扩展性。最后，还需要关注系统的稳定性和安全性。总之，这个问题的解决方案需要综合考虑性能、成本和可维护性等因素，选择最适合当前业务场景的技术方案。
```

**提取的总结性内容**:
```
总之，这个问题的解决方案需要综合考虑性能、成本和可维护性等因素，选择最适合当前业务场景的技术方案。
```

#### 示例2：没有总结关键字
**原始AI响应**:
```
第一步是分析需求和业务场景，明确系统的功能边界。第二步是设计方案架构，选择合适的技术栈和框架。第三步是实施部署，编写代码并进行单元测试。最后，我们需要进行测试验证和性能优化，确保系统稳定运行，并建立完善的监控和告警机制。
```

**提取的总结性内容**:
```
最后，我们需要进行测试验证和性能优化，确保系统稳定运行，并建立完善的监控和告警机制。
```

#### 示例3：字数控制
**原始总结段落**:
```
In summary, this refactoring approach improves code maintainability by separating concerns into distinct modules. The new architecture supports better testability and reduces coupling between components. This results in a more robust and scalable system that can accommodate future changes more easily. Additionally, the modular design allows for better code reuse and easier debugging, making the overall development process more efficient and less error-prone.
```

**提取的总结性内容**:
```
In summary, this refactoring approach improves code maintainability by separating concerns into distinct modules. The new architecture supports better testability and reduces coupling between components. This results in a more robust and scalable system.
```

### 4.2 边界情况示例

#### 示例4：多个总结段落
**原始AI响应**:
```
首先，我们需要对现有代码进行分析和评估。总结来看，代码质量总体良好，但在某些方面存在改进空间。其次，我们应该制定详细的改进计划。总之，建议采用渐进式重构策略，分阶段优化代码结构。
```

**提取的总结性内容**:
```
总结来看，代码质量总体良好，但在某些方面存在改进空间。
```

#### 示例5：最后段落太短
**原始AI响应**:
```
重构的第一步是识别代码中的问题点。第二步是设计新的架构模式。第三步是逐步重构现有代码。第四步是进行测试验证。第五步是性能调优。最后，完成重构。
```

**提取的总结性内容**:
```
第五步是性能调优。最后，完成重构。
```

## 5. 技术实现考虑

### 5.1 集成点
- **AiClient**: 需要在发送请求和接收响应时集成Thread记录功能
- **AiRequest/AiResponse**: 需要支持Thread相关元数据
- **配置系统**: 可能需要添加Thread记录的配置选项

### 5.2 性能考虑
- 文件写入应该是异步的，避免阻塞主线程
- 需要考虑文件并发写入的处理
- 每日文件自动创建和管理机制

### 5.3 错误处理
- 文件写入失败的处理机制
- 文件权限问题的处理
- 磁盘空间不足的处理

## 6. 未来扩展考虑

### 6.1 压缩处理
- 当前版本不实现压缩，为后续版本预留扩展空间
- 可能的压缩方向：
  - 智能摘要生成
  - 重复内容去重
  - 关键信息提取

### 6.2 高级功能
- Thread记录的搜索和查询功能
- Thread记录的可视化展示
- 基于Thread记录的分析和报告生成

## 7. 验收标准

### 7.1 功能验收
- [ ] 手动控制Thread记录启用/禁用
- [ ] 每日自动创建Thread文件
- [ ] 正确记录所有必需的元数据
- [ ] 准确提取总结性内容
- [ ] 正确应用字数控制规则
- [ ] 处理各种边界情况

### 7.2 质量验收
- [ ] 生成的Thread文件格式正确且可读
- [ ] 总结性内容提取准确度高
- [ ] 文件写入稳定可靠
- [ ] 不影响现有功能的性能

## 8. 风险和依赖

### 8.1 技术风险
- 文件I/O性能可能影响整体响应时间
- 并发写入可能导致文件内容混乱
- 磁盘空间可能成为瓶颈

### 8.2 依赖关系
- 依赖于文件系统的权限管理
- 依赖于时间戳的准确性
- 依赖于现有的AI请求/响应流程

---

**文档状态**: 需求确认完成，准备进入设计和实现阶段

**下一步**: 
1. 确定Thread文件的存储位置
2. 设计手动控制机制的具体实现
3. 开始技术方案设计