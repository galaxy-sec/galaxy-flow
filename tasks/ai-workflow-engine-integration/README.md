# AiWorkflowEngine ä¸ Galaxy-flow gxl ç³»ç»Ÿé›†æˆæ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ—¨åœ¨å°† AiWorkflowEngine é›†æˆåˆ° Galaxy-flow çš„ gxl å·¥ä½œæµç³»ç»Ÿä¸­ï¼Œä¸ºç”¨æˆ·æä¾›æ™ºèƒ½åŒ–çš„ AI å·¥ä½œæµèƒ½åŠ›ã€‚é€šè¿‡è¿™ç§é›†æˆï¼Œç”¨æˆ·å¯ä»¥åœ¨ gxl å·¥ä½œæµä¸­ç›´æ¥è°ƒç”¨ AI åŠŸèƒ½ï¼Œå®ç°æ™ºèƒ½åŒ–çš„ä»»åŠ¡æ‰§è¡Œå’Œå†³ç­–ã€‚

## è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡
1. **æ— ç¼é›†æˆ**ï¼šä¸ç°æœ‰çš„ gxl ç³»ç»Ÿå®Œå…¨å…¼å®¹ï¼Œä¸ç ´åç°æœ‰åŠŸèƒ½
2. **æ™ºèƒ½åŒ–**ï¼šæä¾› AI é©±åŠ¨çš„å·¥ä½œæµæ‰§è¡Œèƒ½åŠ›
3. **æ˜“ç”¨æ€§**ï¼šç”¨æˆ·å¯ä»¥ä½¿ç”¨è‡ªç„¶è¯­è¨€æè¿°ä»»åŠ¡ï¼ŒAI è‡ªåŠ¨é€‰æ‹©æ‰§è¡Œæ–¹å¼
4. **å¯æ‰©å±•**ï¼šæ”¯æŒè‡ªå®šä¹‰ AI å·¥å…·å’Œå‡½æ•°

### æŠ€æœ¯ç›®æ ‡
1. **å¤ç”¨ç°æœ‰æ¶æ„**ï¼šå……åˆ†åˆ©ç”¨ Galaxy-flow çš„æˆç†Ÿæ¡†æ¶
2. **æ ‡å‡†åŒ–æ¥å£**ï¼šæä¾›ç»Ÿä¸€çš„ AI ä»»åŠ¡æ‰§è¡Œæ¥å£
3. **æ¨¡å—åŒ–è®¾è®¡**ï¼šå„ç»„ä»¶èŒè´£æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
4. **æµ‹è¯•è¦†ç›–**ï¼šå®Œæ•´çš„æµ‹è¯•ä½“ç³»ç¡®ä¿åŠŸèƒ½ç¨³å®šæ€§

## æ€»ä½“æ¶æ„è®¾è®¡

### ç³»ç»Ÿå±‚æ¬¡å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Galaxy-flow gxl ç³»ç»Ÿ              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è§£æå±‚ (Parser Layer)                    â”‚
â”‚  - æ‰©å±•è§£æå™¨æ”¯æŒ AI æŒ‡ä»¤                 â”‚
â”‚  - æ”¯æŒ gx.ai_fun, gx.ai_workflow è¯­æ³•    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¨¡å‹å±‚ (Model Layer)                     â”‚
â”‚  - æ‰©å±• GxlFlow, GxlFun æ•°æ®ç»“æ„         â”‚
â”‚  - é›†æˆ AI ä»»åŠ¡æ³¨å†Œå’Œå‘ç°æœºåˆ¶             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  èƒ½åŠ›å±‚ (Ability Layer)                    â”‚
â”‚  - GxAIFun: AI å•ä»»åŠ¡æ‰§è¡Œå™¨              â”‚
â”‚  - GxAIWorkflow: AI å·¥ä½œæµæ‰§è¡Œå™¨         â”‚
â”‚  - å¤ç”¨ç°æœ‰ GxAIChat èƒ½åŠ›               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ‰§è¡Œå±‚ (Execution Layer)                  â”‚
â”‚  - AsyncRunnableTrait æ‰§è¡Œæ¡†æ¶             â”‚
â”‚  - å‡½æ•°è°ƒç”¨å’Œå·¥å…·æ‰§è¡Œæœºåˆ¶                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AI é›†æˆå±‚ (AI Integration Layer)         â”‚
â”‚  - AiClient: AI å®¢æˆ·ç«¯                   â”‚
â”‚  - FunctionRegistry: å‡½æ•°æ³¨å†Œè¡¨            â”‚
â”‚  - GitFunctionExecutor: Git å·¥å…·æ‰§è¡Œå™¨    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)      â”‚
â”‚  - é”™è¯¯å¤„ç†ã€æ—¥å¿—ã€é…ç½®ç®¡ç†              â”‚
â”‚  - ä¸ç°æœ‰ orion_ai æ¡†æ¶çš„é›†æˆ          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 1. GxAIFun - AI å•ä»»åŠ¡æ‰§è¡Œå™¨
```rust
pub struct GxAIFun {
    role: Option<String>,              // AI è§’è‰²
    task: Option<String>,               // ä»»åŠ¡æè¿°
    prompt: Option<String>,            // è‡ªå®šä¹‰æç¤ºè¯
    tools: Option<Vec<String>>,         // å¯ç”¨å·¥å…·åˆ—è¡¨
    enable_function_calling: bool,      // å¯ç”¨å‡½æ•°è°ƒç”¨
    ai_config: Option<AiConfig>,      // AI é…ç½®
}
```

**åŠŸèƒ½ç‰¹æ€§**ï¼š
- æ”¯æŒè‡ªç„¶è¯­è¨€ä»»åŠ¡æè¿°
- æ™ºèƒ½å·¥å…·è°ƒç”¨æœºåˆ¶
- è§’è‰²åŒ– AI åŠ©æ‰‹
- é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

#### 2. GxAIWorkflow - AI å·¥ä½œæµæ‰§è¡Œå™¨
```rust
pub struct GxAIWorkflow {
    role: Option<String>,              // AI è§’è‰²
    task: Option<String>,               // æ•´ä½“ä»»åŠ¡æè¿°
    tools: Option<Vec<String>>,         // å·¥ä½œæµå¯ç”¨å·¥å…·
    steps: Option<Vec<WorkflowStep>>,  // å·¥ä½œæµæ­¥éª¤ï¼ˆå¯é€‰ï¼‰
}
```

**åŠŸèƒ½ç‰¹æ€§**ï¼š
- è‡ªåŠ¨ä»»åŠ¡åˆ†è§£å’Œç¼–æ’
- æ™ºèƒ½æ­¥éª¤ä¾èµ–ç®¡ç†
- åŠ¨æ€å·¥å…·é€‰æ‹©
- çŠ¶æ€è·Ÿè¸ªå’Œæ¢å¤

#### 3. AITaskRegistry - AI ä»»åŠ¡æ³¨å†Œè¡¨
```rust
pub struct AITaskRegistry {
    tasks: HashMap<String, AITaskDefinition>,
    dependencies: HashMap<String, Vec<String>>,
}
```

**åŠŸèƒ½ç‰¹æ€§**ï¼š
- åŠ¨æ€ä»»åŠ¡æ³¨å†Œ
- ä»»åŠ¡ä¾èµ–å…³ç³»ç®¡ç†
- ä»»åŠ¡å‘ç°å’ŒæŸ¥è¯¢
- ç‰ˆæœ¬åŒ–ä»»åŠ¡ç®¡ç†

## è¯­æ³•è®¾è®¡

### gx.ai_fun è¯­æ³•

```gxl
mod ai_tools {
    flow git_status_check {
        gx.ai_fun(
            role: "developer",
            task: "æ£€æŸ¥å½“å‰ Git ä»“åº“çŠ¶æ€",
            tools: ["git status"]
        );
    }

    flow smart_commit {
        gx.ai_fun(
            role: "developer",
            task: "ç”Ÿæˆå¹¶æ‰§è¡Œ Git æäº¤",
            tools: ["git status", "git add", "git commit"],
            enable_function_calling: true
        );
    }
}
```

**å‚æ•°è¯´æ˜**ï¼š
- `role`: AI è§’è‰²åç§°ï¼ˆå¯é€‰ï¼Œé»˜è®¤ "developer"ï¼‰
- `task`: ä»»åŠ¡æè¿°ï¼ˆå¯é€‰ï¼‰
- `prompt`: è‡ªå®šä¹‰æç¤ºè¯ï¼ˆå¯é€‰ï¼‰
- `tools`: å¯ç”¨å·¥å…·åˆ—è¡¨ï¼ˆå¯é€‰ï¼Œé»˜è®¤å¯ç”¨ Git å·¥å…·ï¼‰
- `enable_function_calling`: å¯ç”¨å‡½æ•°è°ƒç”¨ï¼ˆå¯é€‰ï¼Œé»˜è®¤ falseï¼‰
- `ai_config`: AI é…ç½®ï¼ˆå¯é€‰ï¼‰

### gx.ai_workflow è¯­æ³•

```gxl
mod ai_workflows {
    flow complete_git_workflow {
        // å…ˆæ³¨å†Œä¸€äº›ä»»åŠ¡
        gx.ai_fun(
            register_as: "diff_checker",
            role: "developer",
            task: "æ£€æŸ¥ä»£ç å˜æ›´",
            tools: ["git diff", "git status"]
        );

        gx.ai_fun(
            register_as: "file_committer",
            role: "developer",
            task: "æäº¤ä»£ç å˜æ›´",
            tools: ["git add", "git commit"]
        );

        // æ‰§è¡Œå®Œæ•´çš„ AI å·¥ä½œæµ
        gx.ai_workflow(
            role: "devops_engineer",
            task: "æ‰§è¡Œå®Œæ•´çš„ Git å·¥ä½œæµï¼šæ£€æŸ¥å˜æ›´ã€ç”Ÿæˆæäº¤æ¶ˆæ¯ã€æäº¤å¹¶æ¨é€ä»£ç "
        );
    }
}
```

**å‚æ•°è¯´æ˜**ï¼š
- `role`: AI è§’è‰²ï¼ˆå¯é€‰ï¼Œé»˜è®¤ "developer"ï¼‰
- `task`: æ•´ä½“ä»»åŠ¡æè¿°ï¼ˆå¿…éœ€ï¼‰
- `tools`: å·¥ä½œæµå¯ç”¨å·¥å…·ï¼ˆå¯é€‰ï¼‰
- `steps`: é¢„å®šä¹‰å·¥ä½œæµæ­¥éª¤ï¼ˆå¯é€‰ï¼ŒAI å¯è‡ªåŠ¨ç”Ÿæˆï¼‰

## æ™ºèƒ½æ‰§è¡Œæœºåˆ¶

### ä»»åŠ¡åˆ†ææµç¨‹

```
ç”¨æˆ·ä»»åŠ¡è¾“å…¥
    â†“
AI ä»»åŠ¡åˆ†æ
    â†“
å·¥å…·éœ€æ±‚è¯„ä¼°
    â†“
å‡½æ•°è°ƒç”¨æ„å»º
    â†“
å·¥å…·æ‰§è¡Œå¤„ç†
    â†“
ç»“æœæ±‡æ€»åé¦ˆ
```

### æ™ºèƒ½å†³ç­–æœºåˆ¶

1. **ä»»åŠ¡ç†è§£**ï¼šAI åˆ†æç”¨æˆ·éœ€æ±‚ï¼Œç¡®å®šä»»åŠ¡ç›®æ ‡
2. **å·¥å…·é€‰æ‹©**ï¼šæ ¹æ®ä»»åŠ¡æè¿°æ™ºèƒ½é€‰æ‹©åˆé€‚çš„å·¥å…·
3. **å‚æ•°ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆå·¥å…·è°ƒç”¨å‚æ•°
4. **æ‰§è¡Œç¼–æ’**ï¼šæŒ‰ä¾èµ–å…³ç³»ç»„ç»‡å·¥å…·è°ƒç”¨é¡ºåº
5. **é”™è¯¯å¤„ç†**ï¼šæ™ºèƒ½è¯Šæ–­é”™è¯¯å¹¶æä¾›æ¢å¤å»ºè®®

### å‡½æ•°è°ƒç”¨ç¤ºä¾‹

```json
{
  "tool_calls": [
    {
      "function": {
        "name": "git-status",
        "arguments": "{\"path\":\".\"}"
      }
    },
    {
      "function": {
        "name": "git-diff",
        "arguments": "{\"staged\":false}"
      }
    }
  ]
}
```

## åˆ†æœŸå®æ–½è®¡åˆ’

### ç¬¬ä¸€æœŸï¼šåŸºç¡€ AI ä»»åŠ¡æ‰§è¡Œæ¡†æ¶ï¼ˆå·²å®Œæˆï¼‰
**ç›®æ ‡**ï¼šå»ºç«‹åŸºç¡€çš„ AI ä»»åŠ¡æ‰§è¡Œèƒ½åŠ›

**å®æ–½å†…å®¹**ï¼š
- âœ… åˆ›å»º GxAIFun åŸºç¡€ç»“æ„
- âœ… å®ç°åŸºç¡€ AI å¯¹è¯åŠŸèƒ½
- âœ… æ‰©å±•è§£æå™¨æ”¯æŒ `gx.ai_fun` è¯­æ³•
- âœ… é›†æˆåˆ°ç°æœ‰æ‰§è¡Œæ¡†æ¶
- âœ… å®Œæ•´çš„æµ‹è¯•è¦†ç›–

**éªŒæ”¶æ ‡å‡†**ï¼š
- âœ… åŸºç¡€ AI å¯¹è¯å¯ç”¨
- âœ… è¯­æ³•è§£ææ­£ç¡®
- âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡
- âœ… ç¤ºä¾‹æ­£å¸¸è¿è¡Œ

### ç¬¬äºŒæœŸï¼šå¢å¼º AI ä»»åŠ¡èƒ½åŠ›ï¼ˆè¿›è¡Œä¸­ï¼‰
**ç›®æ ‡**ï¼šå®ç°å·¥å…·è°ƒç”¨å’Œå‡½æ•°æ‰§è¡Œæœºåˆ¶

**å®æ–½å†…å®¹**ï¼š
- âœ… å¢å¼º GxAIFun æ”¯æŒå·¥å…·è°ƒç”¨
- ğŸ”„ å®ç°å‡½æ•°è°ƒç”¨é€»è¾‘
- ğŸ”„ æ³¨å†ŒåŸºç¡€ Git å·¥å…·å‡½æ•°
- â³ åˆ›å»ºç¬¬äºŒæœŸæµ‹è¯•ç”¨ä¾‹
- â³ åˆ›å»ºç¬¬äºŒæœŸç¤ºä¾‹

**éªŒæ”¶æ ‡å‡†**ï¼š
- â³ å·¥å…·è°ƒç”¨åŠŸèƒ½å¯ç”¨
- â³ Git æ“ä½œæ­£å¸¸å·¥ä½œ
- â³ å‡½æ•°è°ƒç”¨é€»è¾‘æ­£ç¡®
- â³ æµ‹è¯•è¦†ç›–ç‡è¾¾æ ‡
- â³ ç¤ºä¾‹åŠŸèƒ½å®Œæ•´

### ç¬¬ä¸‰æœŸï¼šAI ä»»åŠ¡æ³¨å†Œæœºåˆ¶
**ç›®æ ‡**ï¼šå®ç°ä»»åŠ¡æ³¨å†Œå’Œé‡ç”¨æœºåˆ¶

**å®æ–½å†…å®¹**ï¼š
- åˆ›å»º AITaskRegistry ç³»ç»Ÿ
- å®ç° AITaskDefinition ç»“æ„
- æ‰©å±• GxAIFun æ”¯æŒä»»åŠ¡æ³¨å†Œ
- é›†æˆåˆ° GxlFlow
- å®ç°ä»»åŠ¡å‘ç°æœºåˆ¶

**éªŒæ”¶æ ‡å‡†**ï¼š
- ä»»åŠ¡æ³¨å†Œæœºåˆ¶å¯ç”¨
- ä»»åŠ¡å¯ä»¥é‡ç”¨
- å‘ç°æœºåˆ¶å·¥ä½œæ­£å¸¸
- ä¸ç°æœ‰æ¡†æ¶å…¼å®¹
- å®Œæ•´æµ‹è¯•è¦†ç›–

### ç¬¬å››æœŸï¼šAI å·¥ä½œæµåŸºç¡€
**ç›®æ ‡**ï¼šå®ç°åŸºç¡€çš„ AI å·¥ä½œæµç¼–æ’

**å®æ–½å†…å®¹**ï¼š
- åˆ›å»º GxAIWorkflow åŸºç¡€ç»“æ„
- å®ç°å·¥ä½œæµæ‰§è¡Œé€»è¾‘
- å®ç°ä»»åŠ¡å‘ç°å’Œé€‰æ‹©æœºåˆ¶
- æ‰©å±•è§£æå™¨æ”¯æŒ `gx.ai_workflow` è¯­æ³•
- é›†æˆåˆ° BlockAction æ¡†æ¶

**éªŒæ”¶æ ‡å‡†**ï¼š
- åŸºç¡€å·¥ä½œæµå¯æ‰§è¡Œ
- ä»»åŠ¡è‡ªåŠ¨å‘ç°æ­£å¸¸
- å·¥ä½œæµç¼–æ’é€»è¾‘æ­£ç¡®
- è¯­æ³•è§£æå®Œæ•´
- æµ‹è¯•è¦†ç›–å…¨é¢

### ç¬¬äº”æœŸï¼šæ™ºèƒ½ Git å·¥ä½œæµæ•´åˆ
**ç›®æ ‡**ï¼šå®ç°å®Œæ•´çš„æ™ºèƒ½ Git å·¥ä½œæµç¤ºä¾‹

**å®æ–½å†…å®¹**ï¼š
- å¢å¼º Git å·¥å…·å‡½æ•°æ”¯æŒ
- åˆ›å»ºæ™ºèƒ½ Git å·¥ä½œæµç¤ºä¾‹
- å®ç°ç«¯åˆ°ç«¯é›†æˆæµ‹è¯•
- å®Œå–„ä½¿ç”¨æ–‡æ¡£
- æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•æ”¯æŒ

**éªŒæ”¶æ ‡å‡†**ï¼š
- å®Œæ•´ Git å·¥ä½œæµå¯ç”¨
- ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡
- æ–‡æ¡£å®Œå–„
- æ€§èƒ½æ»¡è¶³è¦æ±‚
- ç”¨æˆ·ä½“éªŒè‰¯å¥½

## æŠ€æœ¯å®ç°ç»†èŠ‚

### è§£æå™¨é›†æˆ

#### æ–°å¢ AI åŠŸèƒ½è§£æå™¨
```rust
// galaxy-flow/src/parser/inner/ai_fun.rs
pub fn gal_ai_fun(input: &mut &str) -> Result<GxAIFun> {
    let mut ai_fun = GxAIFun::default();
    gal_keyword("gx.ai_fun", input)?;
    let props = action_call_args.parse_next(input)?;

    for one in props {
        let key = one.0.to_lowercase();
        match key {
            "role" => ai_fun.set_role(one.1.to_opt()),
            "task" => ai_fun.set_task(one.1.to_opt()),
            "prompt" => ai_fun.set_prompt(one.1.to_opt()),
            "tools" => ai_fun.set_tools(parse_tools_list(one.1)),
            "enable_function_calling" => {
                ai_fun.set_enable_function_calling(one.1.to_opt().map(parse_bool))
            },
            _ => {/* å¿½ç•¥æœªçŸ¥å‚æ•° */}
        }
    }
    Ok(ai_fun)
}
```

#### BlockAction æ‰©å±•
```rust
pub enum BlockAction {
    AiChat(GxAIChat),      // ç°æœ‰
    AiFun(GxAIFun),        // æ–°å¢
    AiWorkflow(GxAIWorkflow), // åç»­æ–°å¢
    Shell(GxShell),        // ç°æœ‰
    // ... å…¶ä»–ç°æœ‰å˜ä½“
}
```

### å‡½æ•°æ‰§è¡Œæœºåˆ¶

#### Git å·¥å…·æ‰§è¡Œå™¨
```rust
pub struct GitFunctionExecutor;

#[async_trait]
impl FunctionExecutor for GitFunctionExecutor {
    async fn execute(&self, function_call: &FunctionCall) -> AiResult<FunctionResult> {
        match function_call.function.name.as_str() {
            "git-status" => self.execute_git_status(function_call).await,
            "git-add" => self.execute_git_add(function_call).await,
            "git-commit" => self.execute_git_commit(function_call).await,
            "git-push" => self.execute_git_push(function_call).await,
            "git-diff" => self.execute_git_diff(function_call).await,
            _ => Err(AiErrReason::from_logic("unknown function")),
        }
    }
}
```

#### å‡½æ•°æ³¨å†Œè¡¨
```rust
impl FunctionRegistry {
    pub fn register_function(&mut self, function: FunctionDefinition) -> AiResult<()> {
        self.functions.insert(function.name.clone(), function);
        Ok(())
    }

    pub fn register_executor(
        &mut self,
        function_name: &str,
        executor: Arc<dyn FunctionExecutor>
    ) -> AiResult<()> {
        self.executors.insert(function_name.to_string(), executor);
        Ok(())
    }
}
```

### é”™è¯¯å¤„ç†ç­–ç•¥

#### é”™è¯¯ç±»å‹å±‚æ¬¡
```
ExecError (é¡¶å±‚æ‰§è¡Œé”™è¯¯)
    â†“
AiWorkflowError (AI å·¥ä½œæµé”™è¯¯)
    â†“
FunctionCallingError (å‡½æ•°è°ƒç”¨é”™è¯¯)
    â†“
GitOperationError (Git æ“ä½œé”™è¯¯)
    â†“
NetworkError (ç½‘ç»œé”™è¯¯)
```

#### é”™è¯¯æ¢å¤æœºåˆ¶
1. **é‡è¯•ç­–ç•¥**ï¼šç½‘ç»œé”™è¯¯å’Œä¸´æ—¶æ•…éšœè‡ªåŠ¨é‡è¯•
2. **é™çº§å¤„ç†**ï¼šå·¥å…·ä¸å¯ç”¨æ—¶æä¾›æ›¿ä»£æ–¹æ¡ˆ
3. **æ™ºèƒ½è¯Šæ–­**ï¼šAI åˆ†æé”™è¯¯åŸå› å¹¶æä¾›è§£å†³æ–¹æ¡ˆ
4. **çŠ¶æ€ä¿å­˜**ï¼šå·¥ä½œæµä¸­æ–­åå¯æ¢å¤æ‰§è¡Œ

## æµ‹è¯•ç­–ç•¥

### æµ‹è¯•ç±»å‹åˆ’åˆ†

#### 1. å•å…ƒæµ‹è¯•
- **GxAIFun æµ‹è¯•**ï¼šåŸºç¡€åŠŸèƒ½ã€å‚æ•°è§£æã€é”™è¯¯å¤„ç†
- **GxAIWorkflow æµ‹è¯•**ï¼šå·¥ä½œæµç¼–æ’ã€ä»»åŠ¡é€‰æ‹©
- **AITaskRegistry æµ‹è¯•**ï¼šä»»åŠ¡æ³¨å†Œã€å‘ç°ã€ä¾èµ–ç®¡ç†
- **å‡½æ•°æ‰§è¡Œå™¨æµ‹è¯•**ï¼šGit æ“ä½œã€å‚æ•°éªŒè¯ã€é”™è¯¯å¤„ç†

#### 2. é›†æˆæµ‹è¯•
- **è§£æå™¨é›†æˆ**ï¼šè¯­æ³•è§£æã€å‚æ•°ä¼ é€’ã€ç±»å‹è½¬æ¢
- **æ‰§è¡Œæ¡†æ¶é›†æˆ**ï¼šä»»åŠ¡è°ƒåº¦ã€çŠ¶æ€ç®¡ç†ã€ç»“æœå¤„ç†
- **AI æœåŠ¡é›†æˆ**ï¼šå®é™… AI è°ƒç”¨ã€å‡½æ•°è°ƒç”¨ã€å“åº”å¤„ç†

#### 3. ç«¯åˆ°ç«¯æµ‹è¯•
- **å®Œæ•´å·¥ä½œæµæµ‹è¯•**ï¼šä»å®šä¹‰åˆ°æ‰§è¡Œçš„å®Œæ•´æµç¨‹
- **é”™è¯¯åœºæ™¯æµ‹è¯•**ï¼šç½‘ç»œæ•…éšœã€å·¥å…·é”™è¯¯ã€AI å“åº”å¼‚å¸¸
- **æ€§èƒ½æµ‹è¯•**ï¼šæ‰§è¡Œæ•ˆç‡ã€èµ„æºæ¶ˆè€—ã€å¹¶å‘å¤„ç†

#### 4. ç¤ºä¾‹æµ‹è¯•
- **åŸºç¡€åŠŸèƒ½ç¤ºä¾‹**ï¼šç®€å• AI å¯¹è¯ã€å·¥å…·è°ƒç”¨
- **Git å·¥ä½œæµç¤ºä¾‹**ï¼šå®Œæ•´çš„ Git æ“ä½œæµç¨‹
- **å¤æ‚åœºæ™¯ç¤ºä¾‹**ï¼šå¤šæ­¥éª¤ã€å¤šå·¥å…·çš„å¤æ‚å·¥ä½œæµ

### æµ‹è¯•æ•°æ®ç®¡ç†

#### æµ‹è¯•ç”¨ä¾‹ç»“æ„
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_basic_ai_conversation() {
        // æµ‹è¯•åŸºç¡€ AI å¯¹è¯åŠŸèƒ½
        let ai_fun = GxAIFun::default()
            .with_role(Some("developer".to_string()))
            .with_prompt(Some("è¯·å›ç­”ï¼š1+1=?".to_string()));

        let result = ai_fun.async_exec(create_test_context(), create_test_vars()).await;
        assert!(result.is_ok());
    }
}
```

#### Mock æ•°æ®å‡†å¤‡
```rust
fn create_mock_ai_response() -> AiResponse {
    AiResponse {
        content: "1+1=2".to_string(),
        provider: "test-provider".to_string(),
        tool_calls: None,
        // ... å…¶ä»–å­—æ®µ
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### æ‰§è¡Œæ•ˆç‡ä¼˜åŒ–

#### 1. å¹¶å‘æ‰§è¡Œ
```rust
async fn execute_concurrent_tasks(&self, tasks: Vec<AITask>) -> Vec<AITaskResult> {
    let futures = tasks.into_iter().map(|task| self.execute_task(task));
    join_all(futures).await
}
```

#### 2. ç¼“å­˜æœºåˆ¶
```rust
pub struct AITaskCache {
    response_cache: HashMap<String, AiResponse>,
    function_cache: HashMap<String, FunctionResult>,
}

impl AITaskCache {
    pub fn get_cached_response(&self, prompt: &str) -> Option<&AiResponse> {
        self.response_cache.get(prompt)
    }

    pub fn cache_response(&mut self, prompt: String, response: AiResponse) {
        self.response_cache.insert(prompt, response);
    }
}
```

#### 3. æ‡’åŠ è½½
```rust
impl AITaskRegistry {
    pub fn get_task_lazy(&self, name: &str) -> impl Future<Output = Option<AITaskDefinition>> {
        if self.tasks.contains_key(name) {
            Box::pin(future::ready(self.tasks.get(name).cloned()))
        } else {
            Box::pin(self.load_and_register_task(name))
        }
    }
}
```

### èµ„æºç®¡ç†

#### 1. å†…å­˜ç®¡ç†
```rust
pub struct AITaskExecutor {
    max_concurrent_tasks: usize,
    memory_limit: usize,
    current_memory_usage: AtomicUsize,
}

impl AITaskExecutor {
    pub fn can_execute_task(&self, task: &AITask) -> bool {
        self.current_concurrent_tasks.load(Ordering::Relaxed) < self.max_concurrent_tasks
            && self.current_memory_usage.load(Ordering::Relaxed) + task.estimated_memory_usage() <= self.memory_limit
    }
}
```

#### 2. è¿æ¥æ± ç®¡ç†
```rust
pub struct AiClientPool {
    clients: Vec<Arc<AiClient>>,
    current_index: AtomicUsize,
}

impl AiClientPool {
    pub fn get_client(&self) -> Arc<AiClient> {
        let index = self.current_index.fetch_add(1, Ordering::Relaxed) % self.clients.len();
        self.clients[index].clone()
    }
}
```

## éƒ¨ç½²å’Œå‘å¸ƒ

### ç‰ˆæœ¬ç®¡ç†

#### ç‰ˆæœ¬å·è§„èŒƒ
- **ä¸»ç‰ˆæœ¬å·**ï¼šä¸å…¼å®¹çš„ API å˜æ›´
- **æ¬¡ç‰ˆæœ¬å·**ï¼šå‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢
- **ä¿®è®¢ç‰ˆæœ¬å·**ï¼šå‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£

#### å‘å¸ƒæµç¨‹
1. **ä»£ç å†»ç»“**ï¼šåŠŸèƒ½å¼€å‘å®Œæˆï¼Œåœæ­¢æ–°åŠŸèƒ½æ·»åŠ 
2. **æµ‹è¯•éªŒè¯**ï¼šå®Œæ•´æµ‹è¯•å¥—ä»¶é€šè¿‡
3. **æ–‡æ¡£æ›´æ–°**ï¼šAPI æ–‡æ¡£ã€ç”¨æˆ·æŒ‡å—æ›´æ–°
4. **å‘å¸ƒå€™é€‰**ï¼šåˆ›å»º RC ç‰ˆæœ¬è¿›è¡ŒéªŒè¯
5. **æ­£å¼å‘å¸ƒ**ï¼šå‘å¸ƒç¨³å®šç‰ˆæœ¬

### å…¼å®¹æ€§ä¿è¯

#### API å…¼å®¹æ€§
```rust
// ä¿æŒå‘åå…¼å®¹çš„ API è®¾è®¡
impl GxAIFun {
    // æ–°å¢å‚æ•°ä½¿ç”¨ Optionï¼Œç¡®ä¿ç°æœ‰ä»£ç ä¸ç ´å
    pub fn with_tools(self, tools: Option<Vec<String>>) -> Self {
        Self { tools, ..self }
    }

    // æ–°å¢æ–¹æ³•ä¸å½±å“ç°æœ‰è°ƒç”¨
    pub fn enable_function_calling(mut self, enabled: bool) -> Self {
        self.enable_function_calling = enabled;
        self
    }
}
```

#### é…ç½®å…¼å®¹æ€§
```yaml
# æ—§ç‰ˆæœ¬é…ç½®ä»ç„¶æ”¯æŒ
ai_config:
  model: "deepseek-chat"
  api_key: "your-api-key"

# æ–°ç‰ˆæœ¬é…ç½®ï¼ˆå‘åå…¼å®¹ï¼‰
ai_config:
  model: "deepseek-chat"
  api_key: "your-api-key"
  function_calling: true  # æ–°å¢å‚æ•°ï¼Œé»˜è®¤ false
  max_tokens: 4000         # æ–°å¢å‚æ•°ï¼Œä½¿ç”¨é»˜è®¤å€¼
```

## é£é™©è¯„ä¼°å’Œç¼“è§£æªæ–½

### æŠ€æœ¯é£é™©

#### 1. AI æœåŠ¡ç¨³å®šæ€§
**é£é™©æè¿°**ï¼šAI æœåŠ¡å¯èƒ½ä¸å¯ç”¨æˆ–å“åº”å»¶è¿Ÿ
**ç¼“è§£æªæ–½**ï¼š
- å®ç°é‡è¯•æœºåˆ¶å’Œè¶…æ—¶æ§åˆ¶
- æ”¯æŒå¤šä¸ª AI æä¾›å•†çš„æ•…éšœåˆ‡æ¢
- æœ¬åœ°ç¼“å­˜å¸¸ç”¨å“åº”
- é™çº§åˆ°åŸºç¡€åŠŸèƒ½æ¨¡å¼

#### 2. è§£æå™¨å¤æ‚æ€§
**é£é™©æè¿°**ï¼šæ–°è¯­æ³•è§£æå¯èƒ½å½±å“ç°æœ‰åŠŸèƒ½
**ç¼“è§£æªæ–½**ï¼š
- åˆ†é˜¶æ®µå®ç°ï¼Œæ¯æ­¥éªŒè¯å…¼å®¹æ€§
- ä¿æŒç°æœ‰è¯­æ³•å®Œå…¨ä¸å˜
- æ–°è¯­æ³•ä½¿ç”¨æ–°æŒ‡ä»¤å
- å®Œæ•´çš„å›å½’æµ‹è¯•

#### 3. æ€§èƒ½å½±å“
**é£é™©æè¿°**ï¼šAI åŠŸèƒ½å¯èƒ½å½±å“æ•´ä½“æ‰§è¡Œæ€§èƒ½
**ç¼“è§£æªæ–½**ï¼š
- å¼‚æ­¥æ‰§è¡Œä¸é˜»å¡ä¸»æµç¨‹
- æ™ºèƒ½ç¼“å­˜å‡å°‘é‡å¤è°ƒç”¨
- èµ„æºä½¿ç”¨é™åˆ¶å’Œç›‘æ§
- æ€§èƒ½åŸºå‡†æµ‹è¯•å’Œä¼˜åŒ–

### é¡¹ç›®é£é™©

#### 1. å¼€å‘å‘¨æœŸä¼°è®¡
**é£é™©æè¿°**ï¼šåŠŸèƒ½å¤æ‚åº¦å¯èƒ½å¯¼è‡´å¼€å‘å»¶æœŸ
**ç¼“è§£æªæ–½**ï¼š
- åˆ†æœŸå®æ–½ï¼Œæ¯æœŸç‹¬ç«‹å¯äº¤ä»˜
- é¢„ç•™ 20% ç¼“å†²æ—¶é—´
- ä¼˜å…ˆçº§æ’åºï¼Œä¿è¯æ ¸å¿ƒåŠŸèƒ½
- æ•æ·å¼€å‘ï¼Œå®šæœŸè°ƒæ•´è®¡åˆ’

#### 2. ç”¨æˆ·æ¥å—åº¦
**é£é™©æè¿°**ï¼šæ–°åŠŸèƒ½å¯èƒ½ä¸ç¬¦åˆç”¨æˆ·é¢„æœŸ
**ç¼“è§£æªæ–½**ï¼š
- æ—©æœŸç”¨æˆ·åé¦ˆæ”¶é›†
- æä¾›å¹³æ»‘è¿ç§»è·¯å¾„
- è¯¦ç»†çš„ä½¿ç”¨æ–‡æ¡£å’Œç¤ºä¾‹
- æ¸è¿›å¼åŠŸèƒ½æ¨å¹¿

## ç›‘æ§å’Œè¯Šæ–­

### æ‰§è¡Œç›‘æ§

#### æ€§èƒ½æŒ‡æ ‡
```rust
pub struct AITaskMetrics {
    execution_time: Histogram,
    success_rate: Counter,
    error_rate: Counter,
    ai_response_time: Histogram,
    function_call_time: Histogram,
}

impl AITaskMetrics {
    pub fn record_execution(&self, duration: Duration, success: bool) {
        self.execution_time.record(duration);
        if success {
            self.success_rate.increment(1);
        } else {
            self.error_rate.increment(1);
        }
    }
}
```

#### çŠ¶æ€è·Ÿè¸ª
```rust
#[derive(Debug, Clone)]
pub struct WorkflowExecutionState {
    workflow_id: String,
    current_step: usize,
    total_steps: usize,
    step_status: Vec<StepStatus>,
    start_time: SystemTime,
    estimated_completion: Option<SystemTime>,
}

impl WorkflowExecutionState {
    pub fn update_step_status(&mut self, step_index: usize, status: StepStatus) {
        if let Some(step_status) = self.step_status.get_mut(step_index) {
            *step_status = status;
        }
    }
}
```

### è¯Šæ–­å·¥å…·

#### æ‰§è¡Œæ—¥å¿—
```rust
pub struct AITaskLogger {
    log_level: LogLevel,
    log_file: Option<PathBuf>,
}

impl AITaskLogger {
    pub fn log_task_start(&self, task: &AITaskDefinition) {
        info!("Starting AI task: {} - {}", task.name(), task.description());
    }

    pub fn log_function_call(&self, call: &FunctionCall, result: &FunctionResult) {
        info!("Function call: {} - Result: {:?}", call.function.name, result);
    }

    pub fn log_task_completion(&self, task: &AITaskDefinition, duration: Duration) {
        info!("Completed AI task: {} in {:?}", task.name(), duration);
    }
}
```

#### è°ƒè¯•æ¥å£
```rust
pub struct AITaskDebugger {
    breakpoints: Vec<String>,
    step_mode: bool,
}

impl AITaskDebugger {
    pub fn check_breakpoint(&self, step_name: &str) -> bool {
        self.breakpoints.contains(&step_name.to_string())
    }

    pub fn enable_step_mode(&mut self, enabled: bool) {
        self.step_mode = enabled;
    }
}
```

## æ–‡æ¡£å’ŒåŸ¹è®­

### ç”¨æˆ·æ–‡æ¡£

#### å¿«é€Ÿå¼€å§‹æŒ‡å—
```markdown
# AI å·¥ä½œæµå¿«é€Ÿå¼€å§‹

## 1. åŸºç¡€ AI å¯¹è¯

```gxl
mod ai_basics {
    flow chat_test {
        gx.ai_fun(
            role: "developer",
            prompt: "è¯·å›ç­”ï¼š1+1=?"
        );
    }
}
```

## 2. å·¥å…·è°ƒç”¨

```gxl
mod ai_tools {
    flow git_check {
        gx.ai_fun(
            role: "developer",
            task: "æ£€æŸ¥ Git çŠ¶æ€",
            tools: ["git status"],
            enable_function_calling: true
        );
    }
}
```

## 3. æ™ºèƒ½å·¥ä½œæµ

```gxl
mod ai_workflows {
    flow smart_commit {
        gx.ai_workflow(
            role: "developer",
            task: "æ‰§è¡Œæ™ºèƒ½ Git æäº¤æµç¨‹"
        );
    }
}
```
```

#### API å‚è€ƒæ–‡æ¡£
```markdown
# GxAIFun API å‚è€ƒ

## æ„é€ å‡½æ•°
- `new()` - åˆ›å»ºæ–°çš„ GxAIFun å®ä¾‹

## è®¾ç½®æ–¹æ³•
- `with_role(role: Option<String>)` - è®¾ç½® AI è§’è‰²
- `with_task(task: Option<String>)` - è®¾ç½®ä»»åŠ¡æè¿°
- `with_prompt(prompt: Option<String>)` - è®¾ç½®è‡ªå®šä¹‰æç¤ºè¯
- `with_tools(tools: Option<Vec<String>>)` - è®¾ç½®å¯ç”¨å·¥å…·
- `with_enable_function_calling(enabled: bool)` - å¯ç”¨å‡½æ•°è°ƒç”¨

## æ‰§è¡Œæ–¹æ³•
- `async async_exec(ctx: ExecContext, vars_dict: VarSpace) -> TaskResult` - æ‰§è¡Œ AI ä»»åŠ¡
```

### å¼€å‘è€…æ–‡æ¡£

#### æ‰©å±•æŒ‡å—
```markdown
# è‡ªå®šä¹‰ AI å·¥å…·å¼€å‘

## 1. å®ç°å·¥å…·å‡½æ•°

```rust
pub struct CustomToolExecutor;

#[async_trait]
impl FunctionExecutor for CustomToolExecutor {
    async fn execute(&self, function_call: &FunctionCall) -> AiResult<FunctionResult> {
        match function_call.function.name.as_str() {
            "custom_function" => self.execute_custom_function(function_call).await,
            _ => Err(AiErrReason::from_logic("unknown function")),
        }
    }
}
```

## 2. æ³¨å†Œå·¥å…·

```rust
let mut registry = FunctionRegistry::new();
registry.register_function(custom_function_definition)?;
registry.register_executor("custom_function", Arc::new(CustomToolExecutor))?;
```

## 3. é›†æˆåˆ° GxAIFun

```rust
let ai_fun = GxAIFun::default()
    .with_tools(Some(vec!["custom_function".to_string()]))
    .with_enable_function_calling(true);
```
```

#### è´¡çŒ®æŒ‡å—
```markdown
# è´¡çŒ®æŒ‡å—

## ä»£ç è§„èŒƒ
- éµå¾ª Rust ä»£ç é£æ ¼
- ä½¿ç”¨ `async/await` è¿›è¡Œå¼‚æ­¥ç¼–ç¨‹
- é”™è¯¯å¤„ç†ä½¿ç”¨ç°æœ‰çš„ `ExecReason` ä½“ç³»
- æ·»åŠ é€‚å½“çš„æ–‡æ¡£æ³¨é‡Š

## æµ‹è¯•è¦æ±‚
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡ä¸ä½äº 80%
- é›†æˆæµ‹è¯•è¦†ç›–ä¸»è¦åŠŸèƒ½è·¯å¾„
- æ¯ä¸ªæ–°åŠŸèƒ½éƒ½æœ‰å¯¹åº”çš„æµ‹è¯•
- ç¡®ä¿æ‰€æœ‰æµ‹è¯•é€šè¿‡

## æäº¤æµç¨‹
1. Fork é¡¹ç›®ä»“åº“
2. åˆ›å»ºåŠŸèƒ½åˆ†æ”¯
3. å®ç°åŠŸèƒ½å¹¶æ·»åŠ æµ‹è¯•
4. ç¡®ä¿æ‰€æœ‰æ£€æŸ¥é€šè¿‡
5. æäº¤ Pull Request
6. ç­‰å¾…ä»£ç å®¡æŸ¥å’Œåˆå¹¶
```

## æ€»ç»“

è¿™ä¸ªé›†æˆæ–¹æ¡ˆæä¾›äº†ä¸€ä¸ªå®Œæ•´ã€å¯æ‰©å±•ã€ç”¨æˆ·å‹å¥½çš„ AI å·¥ä½œæµå¼•æ“ä¸ Galaxy-flow gxl ç³»ç»Ÿçš„é›†æˆæ–¹æ¡ˆã€‚é€šè¿‡åˆ†é˜¶æ®µå®æ–½ã€æ¨¡å—åŒ–è®¾è®¡ã€å®Œå–„çš„æµ‹è¯•ä½“ç³»ï¼Œç¡®ä¿é¡¹ç›®çš„æˆåŠŸäº¤ä»˜ã€‚

### å…³é”®ä¼˜åŠ¿
1. **æŠ€æœ¯å…ˆè¿›æ€§**ï¼šå……åˆ†åˆ©ç”¨ç°æœ‰çš„æˆç†Ÿæ¡†æ¶å’Œ AI æŠ€æœ¯
2. **ç”¨æˆ·ä½“éªŒ**ï¼šè‡ªç„¶çš„è¯­è¨€äº¤äº’ï¼Œæ™ºèƒ½çš„ä»»åŠ¡æ‰§è¡Œ
3. **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„æ¶æ„ï¼Œå®Œæ•´çš„æµ‹è¯•è¦†ç›–
4. **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºåŠŸèƒ½æ‰©å±•

### æˆåŠŸæŒ‡æ ‡
- åŠŸèƒ½å®Œæ•´æ€§ï¼šæ‰€æœ‰è®¡åˆ’åŠŸèƒ½æŒ‰æ—¶äº¤ä»˜
- ä»£ç è´¨é‡ï¼šæµ‹è¯•è¦†ç›–ç‡é«˜ï¼Œä»£ç å®¡æŸ¥é€šè¿‡
- ç”¨æˆ·æ»¡æ„åº¦ï¼šç”¨æˆ·åé¦ˆç§¯æï¼Œä½¿ç”¨åœºæ™¯ä¸°å¯Œ
- ç³»ç»Ÿç¨³å®šæ€§ï¼šè¿è¡Œç¨³å®šï¼Œé”™è¯¯ç‡ä½

é€šè¿‡è¿™ä¸ªæ–¹æ¡ˆçš„å®æ–½ï¼Œå°†ä¸º Galaxy-flow ç”¨æˆ·å¸¦æ¥å¼ºå¤§çš„ AI å·¥ä½œæµèƒ½åŠ›ï¼Œæ˜¾è‘—æå‡å¼€å‘æ•ˆç‡å’Œæ™ºèƒ½åŒ–æ°´å¹³ã€‚
